% Copyright (C) Rosita Wachenchauzer <rositaw@gmail.com>
% Copyright (C) Margarita Manterola <margamanterola@gmail.com>

% Esta obra está licenciada de forma dual, bajo las licencias Creative
% Commons:
%  * Atribución-Compartir Obras Derivadas Igual 2.5 Argentina
%    http://creativecommons.org/licenses/by-sa/2.5/ar/
%  * Atribución-Compartir Obras Derivadas Igual 3.0 Unported
%    http://creativecommons.org/licenses/by-sa/3.0/deed.es_AR.
%
% A su criterio, puede utilizar una u otra licencia, o las dos.
% Para ver una copia de las licencias, puede visitar los sitios
% mencionados, o enviar una carta a Creative Commons,
% 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

\chapter{Decisiones}

Nos plantean el siguiente problema:
\problemac{Debemos leer un número y, si el número es positivo, debemos escribir
en pantalla el cartel ``Numero positivo''.}

\begin{solucion}
Especificamos nuestra solución: se deberá leer un número \lstinline!x!.
Si \lstinline!x > 0! se escribe el mensaje \lstinline!"Número positivo"!.

Diseñamos nuestra solución:

\begin{enumerate}
\item Solicitar al usuario un número, guardarlo en \lstinline!x!.
\item Si $x>0$, imprimir \lstinline!"Numero positivo"!
\end{enumerate}

Es claro que la primera línea se puede traducir como
\begin{codigo-python-sn}
       x = input("Ingrese un numero: ")
\end{codigo-python-sn}

Sin embargo, con las instrucciones que vimos hasta ahora no podemos tomar
el tipo de decisiones que nos planteamos en la segunda línea de este
diseño.
\end{solucion}

Para resolver este problema introducimos una nueva instrucción que
llamaremos {\it condicional} que tiene la siguiente forma:

\begin{codigo-python-sn}
if <condición>:
    <hacer algo si se da la condición>
\end{codigo-python-sn}

Donde \lstinline+if+ es una palabra reservada.

¿Qué es la condición que aparece luego de la palabra reservada \lstinline+if+?
Antes de seguir adelante con la construcción debemos introducir
un nuevo tipo de expresión que nos indicará si se da una cierta situación o no.
Hasta ahora las expresiones con las que trabajamos fueron de tipo numérica y de tipo texto.
Pero ahora la respuesta que buscamos es de tipo {\it sí} o {\it no}.

\section{Expresiones booleanas}

Además de los números y los textos que vimos hasta ahora, Python introduce
las constantes \lstinline!True! y \lstinline!False! para representar los
valores de verdad {\it verdadero} y {\it falso} respectivamente.

Vimos que una expresión es un trozo de código Python que produce o calcula
un valor (resultado). Una {\it expresión booleana} o {\it expresión lógica}
es una expresión que vale o bien \lstinline!True! o bien \lstinline!False!.

\subsection{Expresiones de comparación}

En el ejemplo que queremos resolver, la condición que queremos ver si se
cumple o no es que \lstinline!x! sea mayor que cero. Python provee las
llamadas {\it expresiones de comparación} que sirven para comparar valores
entre sí, y que por lo tanto permiten codificar ese tipo de pregunta.  En
particular la pregunta de si \lstinline!x! es mayor que cero, se codifica
en Python como \lstinline!x > 0!.

De esta forma, \lstinline+5 > 3+ es una expresión booleana cuyo valor es
\lstinline!True!, y \lstinline+5 < 3+ también es una expresión booleana, pero su
valor es \lstinline!False!.

\begin{codigo-python-sn}
>>> 5 > 3
True
>>> 3 > 5
False
>>>
\end{codigo-python-sn}

Los expresiones
booleanas de comparación que provee Python son las siguientes:

\begin{tabular}[c]{|l|l|}
\hline {\bf Expresión} & {\bf Significado}\\
\hline \hline
\lstinline!a == b!& \lstinline!a! es igual a \lstinline!b! \\\hline
\lstinline+a != b+& \lstinline!a! es distinto de \lstinline!b! \\\hline
\lstinline!a < b!& \lstinline!a! es menor que \lstinline!b! \\\hline
\lstinline!a <= b!& \lstinline!a! es menor o igual que \lstinline!b! \\\hline
\lstinline!a > b!& \lstinline!a! es mayor que \lstinline!b! \\\hline
\lstinline!a >= b!& \lstinline!a! es mayor o igual que \lstinline!b! \\\hline
\end{tabular}

A continuación, algunos ejemplos de uso de estos operadores:

\begin{codigo-python-sn}
>>> 6==6
True
>>> 6!=6
False
>>> 6>6
False
>>> 6>=6
True
>>> 6>4
True
>>> 6<4
False
>>> 6<=4
False
>>> 4<6
True
>>>
\end{codigo-python-sn}

\subsection{Operadores lógicos}

De la misma manera que se puede operar entre números mediante las
operaciones de suma, resta, etc., también existen tres operadores lógicos
para combinar expresiones booleanas: \lstinline!and! (y), \lstinline!or!
(o) y \lstinline!not! (no).

El significado de estos operadores es igual al del castellano, pero vale la pena recordarlo:

\begin{tabular}[c]{|l|l|}
\hline {\bf Expresión} & {\bf Significado}\\
\hline \hline
\lstinline!a and b!& El resultado es \lstinline!True! solamente si
\lstinline!a! es \lstinline!True! y  \lstinline!b! es \lstinline!True! \\
& de lo contrario el resultado es \lstinline!False!\\\hline
\lstinline!a or b!& El resultado es \lstinline!True! si \lstinline!a! es
\lstinline!True! o  \lstinline!b! es \lstinline!True! \\
& de lo contrario el resultado es \lstinline!False!\\\hline
\lstinline!not a!& El resultado es \lstinline!True! si \lstinline!a! es
\lstinline!False!\\
& de lo contrario el resultado es \lstinline!False!\\\hline
\end{tabular}

\begin{itemize}
\item \lstinline!a > b and a > c! es verdadero si \lstinline!a! es
simultáneamente mayor que \lstinline!b! y que \lstinline!c!.

\begin{codigo-python-sn}
>>> 5>2 and 5>3
True
>>> 5>2 and 5>6
False
>>>
\end{codigo-python-sn}

\item \lstinline!a > b or a > c! es verdadero si \lstinline!a! es mayor que
\lstinline!b! o \lstinline!a! es mayor que \lstinline!c!.

\begin{codigo-python-sn}
>>> 5>2 or 5>3
True
>>> 5>2 or 5>6
True
>>> 5>8 or 5>6
False
>>>
\end{codigo-python-sn}

\item \lstinline!not (a > b)! es verdadero si \lstinline!a > b! es falso (o
sea si \lstinline!a <= b! es verdadero).

\begin{codigo-python-sn}
>>> 5>8
False
>>> not (5>8)
True
>>> 5>2
True
>>> not (5>2)
False
>>>
\end{codigo-python-sn}

\end{itemize}

\section{Comparaciones simples}

Volvemos al problema que nos plantearon: Debemos leer un número y, si el
número es positivo, debemos escribir en pantalla el mensaje
 \lstinline!"Numero positivo"!.

Utilizando la instrucción \lstinline!if! que acabamos de introducir y que sirve
para tomar decisiones simples. Dijimos que su formato más sencillo es:

\begin{codigo-python-sn}
if <condición>:
    <hacer algo si se da la condición>
\end{codigo-python-sn}

cuyo significado es el siguiente:
se evalúa \lstinline+<condición>+ y si el resultado es \lstinline!True! (verdadero) se
ejecutan las acciones indicadas como {\it $<$hacer algo si se da la condición$>$}.

Como ahora ya sabemos también cómo construir condiciones de comparación,
estamos en condiciones de implementar nuestra solución. Escribimos la
función \lstinline+es_positivo()+ que hace lo pedido:

\begin{codigo-python-sn}
def es_positivo():
    x = input("Ingrese un numero: ")
    if x > 0:
        print "Numero positivo"
\end{codigo-python-sn}

y la probamos:

\begin{codigo-python-sn}
>>> es_positivo()
Ingrese un numero: 4
Numero positivo
>>> es_positivo()
Ingrese un numero: -25
>>> es_positivo()
Ingrese un numero: 0
>>>
\end{codigo-python-sn}

\problemac{
En la etapa de mantenimiento nos dicen que, en realidad, también se
necesitaría un mensaje \lstinline!"Numero no positivo"! cuando no se cumple
la condición.}

Modificamos la especificación consistentemente y modificamos el diseño:

\begin{enumerate}
\item Solicitar al usuario un número, guardarlo en \lstinline!x!.
\item Si $x>0$, imprimir \lstinline!"Numero positivo"!
\item Si no se cumple $x>0$, imprimir \lstinline!"Numero no positivo"!
\end{enumerate}

La negación de $x>0$ es $\neg(x>0)$ que se traduce en Python como
\lstinline!not (x > 0)!, por lo que implementamos nuestra solución en
Python como:

\begin{codigo-python-sn}
def positivo_o_no():
    x = input("Ingrese un numero: ")
    if x > 0:
       print "Numero positivo"
    if not (x > 0):
       print "Numero no positivo"
\end{codigo-python-sn}

Probamos la nueva solución y obtenemos el resultado buscado:

\begin{codigo-python-sn}
>>> positivo_o_no()
Ingrese un numero: 4
Numero positivo
>>> positivo_o_no()
Ingrese un numero: -25
Numero no positivo
>>> positivo_o_no()
Ingrese un numero: 0
Numero no positivo
>>>
\end{codigo-python-sn}

Sin embargo hay algo que nos preocupa: si ya averiguamos una vez, en la segunda
línea del cuerpo, si \lstinline!x > 0!, ¿Es realmente necesario volver a
preguntarlo en la cuarta?.

Existe una construcción alternativa para la estructura de decisión:

{\bf Si se da la condición C, hacer S, de lo contrario, hacer T}. Esta estructura tiene la forma:

\begin{codigo-python-sn}
if <condición>:
    <hacer algo si se da la condición>
else:
	<hacer otra cosa si no se da la condición>
\end{codigo-python-sn}

Donde \lstinline!if! y \lstinline!else! son palabras reservadas.

Su significado es el siguiente: se evalúa \lstinline+<condición>+, si el
resultado es \lstinline!True! (verdadero) se ejecutan las acciones
indicadas como {\it $<$hacer algo si se da la condición$>$}, y si el
resultado es \lstinline!False! (falso) se ejecutan las acciones indicadas
como {\it $<$hacer otra cosa si no se da la condición$>$}.

Volvemos a nuestro diseño:

\begin{enumerate}
\item Solicitar al usuario un número, guardarlo en \lstinline!x!.
\item Si $x>0$, imprimir \lstinline!"Numero positivo"!
\item De lo contrario, imprimir \lstinline!"Numero no positivo"!
\end{enumerate}

Este diseño se implementa como:

\begin{codigo-python-sn}
def positivo_o_no_nue():
    x = input("Ingrese un numero: ")
    if x > 0:
       print "Numero positivo"
    else:
       print "Numero no positivo"
\end{codigo-python-sn}

y lo probamos:

\begin{codigo-python-sn}
>>> positivo_o_no_nue()
Ingrese un numero: 4
Numero positivo
>>> positivo_o_no_nue()
Ingrese un numero: -25
Numero no positivo
>>> positivo_o_no_nue()
Ingrese un numero: 0
Numero no positivo
>>>
\end{codigo-python-sn}

Es importante destacar que, en general, negar la condición del
\lstinline!if! y poner \lstinline!else! no son intercambiables, no
necesariamente producen el mismo efecto en el programa. Notar qué sucede en
los dos programas que se transcriben a continuación. ¿Por qué se dan estos
resultados?:

\noindent
\begin{minipage}[t]{80mm}
\footnotesize
\begin{codigo-python-sn}
>>> def pn():
...     x = input("Ingrese un numero: ")
...     if x > 0:
...        print "Numero positivo"
...        x = -x
...     if x < 0:
...        print "Numero no positivo"
...
>>> pn()
Ingrese un numero: 25
Numero positivo
Numero no positivo
>>>
\end{codigo-python-sn}
\end{minipage}
\begin{minipage}[t]{80mm}
\footnotesize
\begin{codigo-python-sn}
>>> def pn1():
...     x = input("Ingrese un numero: ")
...     if x > 0:
...        print "Numero positivo"
...        x = -x
...     else:
...        print "Numero no positivo"
...
>>> pn1()
Ingrese un numero: 25
Numero positivo
>>>
\end{codigo-python-sn}
\end{minipage}
\normalsize

\section{Múltiples decisiones consecutivas}

La decisión de incluir una alternativa en un programa, parte de una
lectura cuidadosa de la especificación. En nuestro caso la especificación
nos decía:
\begin{quote}
Si el número es positivo escribir un mensaje 
\lstinline!"Numero positivo"!, de lo contrario escribir un mensaje
\lstinline!"Numero no positivo"!.
\end{quote}

Veamos qué se puede hacer cuando se presentan tres o más alternativas:

\problemac{
Si el número es positivo escribir un mensaje 
\lstinline!"Numero positivo"!, si el número es igual a 0 un mensaje
\lstinline!"Igual a 0"!, y si el número es negativo escribir un mensaje
\lstinline!"Numero negativo"!}.

Una posibilidad es considerar que se trata de una estructura con dos
casos como antes, sólo que el segundo caso es complejo (es nuevamente una alternativa):

\begin{enumerate}
\item Solicitar al usuario un número, guardarlo en \lstinline!x!.
\item Si $x>0$, imprimir \lstinline!"Numero positivo"!
\item De lo contrario:
\begin{enumerate}
\item Si $x=0$, imprimir \lstinline!"Igual a 0"!
\item De lo contrario, imprimir \lstinline!"Numero no positivo"!
\end{enumerate}
\end{enumerate}

Este diseño se implementa como:

\begin{codigo-python-sn}
def pcn1():
    x = input("Ingrese un numero: ")
    if x > 0:
       print "Numero positivo"
    else:
       if x == 0:
          print "Igual a 0"
       else:
          print "Numero negativo"
\end{codigo-python-sn}

Esta estructura se conoce como de {\it alternativas anidadas} ya que dentro
de una de las ramas de la alternativa (en este caso la rama del
\lstinline!else!) se anida otra alternativa.

Pero ésta no es la única forma de implementarlo. Existe otra construcción,
equivalente a la anterior pero que no exige sangrías cada vez mayores en el texto.
Se trata de la estructura de {\it alternativas encadenadas}, que tiene la forma

\begin{codigo-python-sn}
if <condición_1>:
    <hacer algo_1 si se da la condición_1>
elif <condición_2>:
    <hacer algo_2 si se da la condición_2>

...

elif <condición_n>:
    <hacer algo_n si se da la condición_n>
else:
	<hacer otra cosa si no se da ninguna de las condiciones anteriores>
\end{codigo-python-sn}

Donde \lstinline!if!, \lstinline!elif! y \lstinline!else! son palabras reservadas.

En nuestro ejemplo:

\begin{codigo-python-sn}
def pcn2():
    x = input("Ingrese un numero: ")
    if x > 0:
       print "Numero positivo"
    elif x == 0:
       print "Igual a 0"
    else:
       print "Numero negativo"
\end{codigo-python-sn}

Se evalúa la primera alternativa, si es verdadera se ejecuta su cuerpo.  De
lo contrario se evalúa la segunda alternativa, si es verdadera se ejecuta
su cuerpo, etc.  Finalmente, si todas las alternativas anteriores fallaron,
se ejecuta el cuerpo del \lstinline!else!.

\begin{sabias_que}
No sólo mediante los operadores vistos (como \lstinline!>! o \lstinline!=!)
es posible obtener expresiones booleanas.  En Python, se consideran
\textit{verdaderos} los valores numéricos distintos de 0, las cadenas de
caracteres que no son vacías, y en general cualquier valor que no sea 0 o
vacío.  Mientras que los valores 0 o vacíos se consideran \textit{falsos}.

Así, el ejemplo anterior también podría escribirse de la siguiente manera:
\begin{codigo-python-sn}
def pcn2():
    x = input("Ingrese un numero: ")
    if x > 0:
       print "Numero positivo"
    elif not x:
       print "Igual a 0"
    else:
       print "Numero negativo"
\end{codigo-python-sn}
\end{sabias_que}


\section{Ejercicios}

\ejercicioc{El usuario del tarifador nos pide ahora una modificación, ya
que no es lo mismo la tarifa por segundo de las llamadas cortas que la
tarifa por segundo de las llamadas largas.  Al inicio del programa se
informará la duración máxima de una llamada corta, la tarifa de las
llamadas cortas y la de las largas. Se deberá facturar con alguno de los
dos valores de acuerdo a la duración de la comunicación.}

\ejercicioc{{\bf Mantenimiento del tarifador:}

\begin{partes}
\item Al nuevo programa que cuenta con llamadas cortas y largas, agregarle
los adicionales, de modo que:
\begin{itemize}
\item Los montos se escriban como pesos y centavos.
\item Se informe además cuál fue el total facturado en la corrida.
\end{itemize}

\item Modificar el programa para que sólo informe cantidad de llamadas
cortas, valor total de llamadas cortas facturadas, cantidad de llamadas
largas, valor total de llamadas largas facturadas, y total facturado. 
Al llegar a este punto debería ser evidente que es conveniente separar los
cálculos en funciones aparte.
\end{partes}
}

\ejercicioc{Dados tres puntos en el plano expresados como coordenadas (x,
y) informar cuál es el que se encuentra más lejos del centro de
coordenadas.}

\section{Resumen}
\begin{itemize}
\item Para poder tomar decisiones en los programas y ejecutar una acción u
otra, es necesario contar con una \textbf{estructura condicional}.  
\item Las \textbf{condiciones} son expresiones \textit{booleanas}, es
decir, cuyos valores pueden ser \textit{verdadero} o \textit{falso}, y se
las confecciona mediante operadores entre distintos valores. 
\item Mediante \textbf{expresiones lógicas} es posible modificar o combinar
expresiones booleanas. 
\item La estructura condicional puede contar, opcionalmente, con un bloque
de código que se ejecuta si no se cumplió la condición.  
\item Es posible \textit{anidar} estructuras condicionales, colocando una
dentro de otra.
\item También es posible \textit{encadenar} las condiciones, es decir,
colocar una lista de posibles condiciones, de las cuales se ejecuta la
primera que sea verdadera.  
\end{itemize}

\newpage
\begin{referencia_python}

\begin{sintaxis}{\lstinline!if <condición>:!}
Bloque condicional.  Las acciones a ejecutar si la condición
es verdadera deben tener un mayor nivel de indentación.
\begin{codigo-python-sn}
if <condición>:
    # acciones a ejecutar si condición es verdadera
\end{codigo-python-sn}
\end{sintaxis}

\begin{sintaxis}{\lstinline!else:!}
Un bloque que se ejecuta cuando no se cumple la condición
correspondiente al \lstinline!if!.  Sólo se puede utilizar 
\lstinline!else! si hay un \lstinline!if! correspondiente.  Debe
escribirse al mismo nivel que \lstinline!if!, y las acciones a ejecutar
deben tener un nivel de indentación mayor.
\begin{codigo-python-sn}
if <condición>:
    # acciones a ejecutar si condición es verdadera
else:
    # acciones a ejecutar si condición es falsa
\end{codigo-python-sn}
\end{sintaxis}

\begin{sintaxis}{\lstinline!elif <condición>:!}
Bloque que se ejecuta si no se cumplieron las condiciones
anteriores pero sí se cumple la condición especificada.  Sólo se puede utilizar
\lstinline!elif! si hay un \lstinline!if! correspondiente, se lo debe
escribir al mismo nivel que \lstinline!if!, y las acciones a ejecutar deben
escribirse en un bloque de indentación mayor.  Puede haber tantos
\lstinline!elif! como se quiera, todos al mismo nivel.
\begin{codigo-python-sn}
if <condición1>:
    # acciones a ejecutar si condición1 es verdadera
elif <condición2>:
	# acciones a ejecutar si condición2 es verdadera
else:
    # acciones a ejecutar si ninguna condición fue verdadera
\end{codigo-python-sn}
\end{sintaxis}

\begin{sintaxis}{Operadores de comparación}
Son los que forman las expresiones booleanas.

\begin{tabular}[c]{|l|l|}
\hline {\bf Expresión} & {\bf Significado}\\
\hline \hline
\lstinline!a == b!& \lstinline!a! es igual a \lstinline!b! \\\hline
\lstinline+a != b+& \lstinline!a! es distinto de \lstinline!b! \\\hline
\lstinline!a < b!& \lstinline!a! es menor que \lstinline!b! \\\hline
\lstinline!a <= b!& \lstinline!a! es menor o igual que \lstinline!b! \\\hline
\lstinline!a > b!& \lstinline!a! es mayor que \lstinline!b! \\\hline
\lstinline!a >= b!& \lstinline!a! es mayor o igual que \lstinline!b! \\\hline
\end{tabular}
\end{sintaxis}

\begin{sintaxis}{Operadores lógicos}
Son los utilizados para concatenar o negar distintas expresiones booleanas.

\begin{tabular}[c]{|l|l|}
\hline {\bf Expresión} & {\bf Significado}\\
\hline \hline
\lstinline!a and b!& El resultado es \lstinline!True! solamente si
\lstinline!a! es \lstinline!True! y  \lstinline!b! es \lstinline!True! \\
& de lo contrario el resultado es \lstinline!False!\\\hline
\lstinline!a or b!& El resultado es \lstinline!True! si \lstinline!a! es
\lstinline!True! o  \lstinline!b! es \lstinline!True! \\
& de lo contrario el resultado es \lstinline!False!\\\hline
\lstinline!not a!& El resultado es \lstinline!True! si \lstinline!a! es
\lstinline!False!\\
& de lo contrario el resultado es \lstinline!False!\\\hline
\end{tabular}
\end{sintaxis}

\end{referencia_python}


\newpage
\section{Ejercicios}

\ejercicio{Escribir funciones que resuelvan los siguientes problemas:
\begin{partes}
    \item Dado un número entero $n$, indicar si es o no par.
    \item Dado un número entero $n$, indicar si es o no primo.
\end{partes}

\ejercicio{Escribir una implementación propia de la función \verb!abs!, 
que devuelva el valor absoluto de cualquier valor que reciba.}

\ejercicio{Escribir una función que reciba por parámetro una dimensión $n$, 
e imprima la matriz identidad correspondiente a esa dimensión.}

\ejercicio{Escribir funciones que permitan encontrar:}
\begin{partes}
    \item  El máximo o mínimo de un polinomio de segundo grado (dados los
coeficientes \verb!a!, \verb!b! y \verb!c!), indicando si es un máximo o un
mínimo.

    \item Las raíces (reales o complejas) de un polinomio de segundo grado. \\
{\bf Nota}: validar que las operaciones puedan efectuarse antes de
realizarlas (no dividir por cero, ni calcular la raíz de un número negativo).

    \item La intersección de dos rectas (dadas las pendientes y ordenada 
 al origen de cada recta). \\
{\bf Nota}: validar que no sean dos rectas con la misma pendiente, antes de
efectuar la operación.
\end{partes}


\ejercicio{Escribir funciones que resuelvan los siguientes problemas:}
\begin{partes}
    \item Dado un año indicar si es bisiesto. \\
{\bf Nota}: un año es bisiesto si es un número divisible por 4, pero no si es
divisible por 100, excepto que también sea divisible por 400.

    \item Dado un mes, devolver la cantidad de días correspondientes.

    \item Dada una fecha (día, mes, año), indicar si es válida o no.

    \item Dada una fecha, indicar los días que faltan hasta fin de mes. 

    \item Dada una fecha, indicar los días que faltan hasta fin de año.

    \item Dada una fecha, indicar la cantidad de días transcurridos en ese año
hasta esa fecha.

    \item Dadas dos fechas (día1, mes1, año1, día2, mes2, año2), indicar el
tiempo transcurrido entre ambas, en años, meses y días.
\end{partes}
{\bf Nota}: en todos los casos, invocar las funciones escritas previamente
cuando sea posible.


\ejercicio{Suponiendo que el primer día del año fue lunes, escribir una función
que reciba un número con el día del año (de 1 a 366) y devuelva el día
de la semana que le toca. Por ejemplo: si recibe '3' debe devolver
'miércoles', si recibe '9' debe devolver 'martes'}

\ejercicio{Escribir un programa que reciba como entrada un año escrito 
en números arábigos y muestre por pantalla el mismo año escrito en números romanos.}

\ejercicio{Programa de astrología: el usuario debe ingresar el día y 
mes de su cumpleaños y el programa le debe decir a que signo corresponde.}
{\bf Nota}: \\
Aries: 21 de marzo al 20 de abril. \\
Tauro: 21 de abril al 20 de mayo. \\
Geminis: 21 de mayo al 21 de junio. \\
Cancer: 22 de junio al 23 de julio. \\
Leo: 24 de julio al 23 de agosto. \\
Virgo: 24 de agosto al 23 de septiembre. \\
Libra: 24 de septiembre al 22 de octubre. \\
Escorpio: 23 de octubre al 22 de noviembre. \\
Sagitario: 23 de noviembre al 21 de diciembre. \\
Capricornio: 22 de diciembre al 20 de enero. \\
Acuario: 21 de enero al 19 de febrero. \\
Piscis: 20 de febrero al 20 de marzo. \\
